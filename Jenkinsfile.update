properties([
	disableConcurrentBuilds(),
	disableResume(),
	durabilityHint('PERFORMANCE_OPTIMIZED'),
	pipelineTriggers([
		cron('@hourly'),
	]),
])

node {
	stage('Checkout') {
		checkout(scmGit(
			userRemoteConfigs: [[
				url: 'git@github.com:docker-library/meta.git',
				credentialsId: 'docker-library-bot',
				name: 'origin',
			]],
			branches: [[name: '*/subset']], // TODO back to main
			extensions: [
				submodule(
					recursiveSubmodules: true,
					parentCredentials: true,
				),
				cleanBeforeCheckout(),
				cleanAfterCheckout(),
				[$class: 'RelativeTargetDirectory', relativeTargetDir: 'meta'],
			],
		))
		sh '''
			git -C meta config user.name 'Docker Library Bot'
			git -C meta config user.email 'doi+docker-library-bot@docker.com'
		'''
	}

	env.BASHBREW_LIBRARY = workspace + '/meta/.doi/library'

	dir('meta') {
		// we *should* update .scripts (since that's where Jenkinsfile.* comes from, so it doesn't really make sense to update our Jenkinsfile and not have it use updated scripts), but it probably should update explicitly to the commit that the Jenkinsfile itself is coming from, if that's possible? ("latest" is probably fine)
		stage('Update DOI') {
			sh '''
				git submodule update --remote --merge .doi
				git submodule update --remote --merge .scripts
			'''
		}

		withCredentials([string(credentialsId: 'dockerhub-public-proxy', variable: 'DOCKERHUB_PUBLIC_PROXY')]) { // thanks to rate limits, we either have to "docker login" or look things up via our proxy
			stage('Fetch') {
				sh 'bashbrew --library .doi/library fetch $(cat subset.txt)' // TODO --all
			}
			stage('Sources') {
				sh '''
					# we only need to regenerate "sources.json" if ".doi", ".scripts", or "subset.txt" have changed since we last generated it
					needsUpdate=
					if ! git diff --exit-code .doi .scripts; then
						# if .doi or .scripts updated in this job ("git submodule update" above)
						needsUpdate=1
					else
						# if subset.txt, .doi, or .scripts updated outside this job (merged PR, etc)
						sourcesCommit="$(git log -1 --format='format:%H' -- sources.json)"
						for f in subset.txt .doi .scripts; do
							commit="$(git log -1 --format='format:%H' -- "$f")"
							if ! git merge-base --is-ancestor "$commit" "$sourcesCommit"; then
								needsUpdate=1
								break
							fi
						done
					fi
					if [ -n "$needsUpdate" ]; then
						.scripts/sources.sh $(cat subset.txt) > sources.json
					fi
				'''
			}
			stage('Builds') {
				sh '.scripts/builds.sh sources.json > builds.json'
			}
		}
		stage('Commit') {
			sh '''
				# only commit submodule updates if our JSON has changed (see https://github.com/docker-library/meta-scripts/pull/8)
				if ! git diff --exit-code sources.json builds.json; then
					git add -A .
					git commit -m 'Update and regenerate'
				fi
			'''
		}
		sshagent(['docker-library-bot']) {
			stage('Push') {
				sh 'git push origin HEAD:subset' // TODO back to main
			}
		}
	}
}
